%%cuda
//#Add Kernel i used for tests

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#include <time.h>
#include <sys/time.h>


#include <cuda.h>
#include <cuda_runtime.h>



uint64_t get_time_us(void) {
    struct timespec a;
    clock_gettime(CLOCK_MONOTONIC, &a);
    return (uint64_t) (((double) a.tv_nsec / 1000.0) + ((double) a.tv_sec * (1000.0 * 1000.0)));
}


void initializeAddKernel(double *grid, uint32_t h, uint32_t w)
{

	for (uint32_t i = 0; i < h; ++i)
	{
		for (uint32_t j = 0; j < w; ++j)
		{
			
				grid[w * i + j] = 3.0;
			
		}
	}
}
void printGrid(double *grid, uint32_t h, uint32_t w)
{

	for (uint32_t i = 0; i < h; ++i)
	{
		for (uint32_t j = 0; j < w; ++j)
		{
			
			printf("i:%" PRId32 " j:%" PRId32 " = %f\t" , i,j, grid[w * i + j]);
			
		}
        printf("\n");
	}
}
__global__ void addKernel(double *grid_source, double *grid_target, double *result, uint32_t x, uint32_t y)
{
    uint32_t i = blockIdx.x * blockDim.x + threadIdx.x;
    uint32_t j = blockIdx.y * blockDim.y + threadIdx.y;
    if (i < x && j < x)
    {
        result[x * i + j] = grid_source[x * i + j ] + grid_target[x * i +  j];
    }
}

__global__ void update_grid(double *grid_source, double *grid_target, uint32_t x, uint32_t y)
{
    uint32_t i = blockIdx.x * blockDim.x + threadIdx.x;
    uint32_t j = blockIdx.y * blockDim.y + threadIdx.y;
    if (i > 0 && i < x && j > 0 && j < x)
    //if (i < x && j < x)
    {
        grid_target[x * i + j] = 0.25 * (grid_source[x * i + (j - 1)] + grid_source[x * i + (j + 1)] +
                                         grid_source[x * (i - 1) + j] + grid_source[x * (i + 1) + j]);
    }

   
}



typedef struct COLOR_s {
   unsigned char r; // red channel
   unsigned char g; // green channel
   unsigned char b; // blue channel
} COLOR;
unsigned char convertValue(double value) {
    return (unsigned char)(value * 255);
}

static COLOR color_converter(double value) {
    COLOR c;
    c.r = 0;
    c.g = 0;
    c.b = 0;

    // TODO color mapping
    if (value<=0.25 )
    {
        c.r=0;
        //Green has slope 1
        c.g=convertValue(value);
        c.b=255;
    }
    else if (value<=0.5 )
    {
        c.r=0;
        c.g=255;
         //Blue has slope 1
        c.b=convertValue(value);
    }
    else if (value<=0.75 )
    {
        //Red has slope 1
        c.r=convertValue(value);;
        c.g=255;
        c.b=0;
    }
    else
    {
        c.r=255;
        c.g=convertValue(value);;
         //Blue has slope 1
        c.b=0;
    }
    
    return c;
}



void draw_grid(double* grid, uint32_t x, uint32_t y, const char* filepath) {

    FILE *fp = fopen(filepath, "w");
    if (fp != NULL) {
        // Write the PPM header with meta information
        fprintf(fp, "P3\n%d %d\n255\n", x, y);

        // Iterate through the grid and convert values to color
        for (uint32_t i = 0; i < y; ++i) {
            for (uint32_t j = 0; j < x; ++j) {
                // Pass grid value and convert it to a COLOR struct
                COLOR c = color_converter(grid[x * i + j]);
              //debugger  COLOR c = color_converter((double)rand() / RAND_MAX);
                fprintf(fp, "%d %d %d\n", c.r, c.g, c.b);
            }
        }

        // Close the file
        fclose(fp);
    } else {
        // Handle the case where file opening fails
        printf("Failed to open the file for writing.\n");
    }
    
}

void initialize_grid(double *grid, uint32_t h, uint32_t w)
{

	for (uint32_t i = 0; i < h; ++i)
	{
		for (uint32_t j = 0; j < w; ++j)
		{
			if (i == 0 || j == 0)
			{
				grid[w * i + j] = 1.0;
			}
			else
			{
				grid[w * i + j] = 0.0;
			}
		}
	}
}

void swap(double** grid_target, double** grid_source) {
    double* temp = *grid_target;
    *grid_target = *grid_source;
    *grid_source = temp;
}


int main(int argc, char *argv[])
{
	uint64_t start = 0u;
	uint64_t stop = 0u;
	uint64_t actual_runtime_without_copy = 0u;
	uint64_t actual_runtime_with_copy = 0u;

	uint64_t actual_runtime = 0u;
	 uint64_t runs = 0u;
	 uint64_t minimal_runtime = 1000000;

	double *d_gridSource;
	double *d_gridTarget;
	//# double *d_result;
 
 uint64_t GRID_SIZE =1048576;

	uint64_t gridLength = GRID_SIZE / sizeof(double);
	uint64_t edge_size = sqrt(gridLength) - 4;
	printf(" edge_size:%" PRId64 "\n", edge_size);

	uint64_t num_rows = edge_size;
	uint64_t num_cols = num_rows;

	double *h_gridSource = (double *)malloc(gridLength * sizeof(double));
	double *h_gridTarget = (double *)malloc(gridLength * sizeof(double));
  double *h_resultGrid = (double *)malloc(gridLength * sizeof(double));

	 initialize_grid(h_gridSource, num_rows, num_cols);
	 initialize_grid(h_gridTarget, num_rows, num_cols);

	//# initializeAddKernel(h_gridSource, num_rows, num_cols);
	//# initializeAddKernel(h_gridTarget, num_rows, num_cols);

	printf("\n Row:%" PRId64 " Column:%" PRId64 "\n", num_rows, num_cols);

	//# Allocate memory
	cudaMalloc((void **)&d_gridSource, sizeof(double) * gridLength);
	cudaMalloc((void **)&d_gridTarget, sizeof(double) * gridLength);
	//# cudaMalloc((void **)&d_result, sizeof(double) * gridLength);

	//# Copy data from host to device
	cudaMemcpy(d_gridSource, h_gridSource, sizeof(double) * gridLength, cudaMemcpyHostToDevice);
	cudaMemcpy(d_gridTarget, h_gridTarget, sizeof(double) * gridLength, cudaMemcpyHostToDevice);

	

	//# set kernel dimension
	//# RTX GPU SM
	//# 32x32 =1024
	uint RTX_MAX_THREAD_BLOCK = 1024;
	uint x_count = sqrt(RTX_MAX_THREAD_BLOCK);
	uint y_count = x_count;

	dim3 block_size(x_count, y_count);
	uint x = (num_cols + block_size.x - 1) / block_size.x;
	uint y = (num_rows + block_size.y - 1) / block_size.y;
	dim3 grid_size(x, y);




	printf("BLOCK_DIM:%dx%d  GRID_DIM:%dx%d GRIDLENGTH:%" PRId64 "\n", block_size.y, block_size.x, grid_size.x, grid_size.y, gridLength);

	 for (runs = 1u; actual_runtime < minimal_runtime; runs = runs << 1u)
	{
	start = get_time_us();

	 for (uint64_t i = 0u; i < runs; i++)
	{
	//# serial_update_grid(h_gridSource, h_gridTarget, num_cols, num_rows);
	//# swap(&h_gridSource, &h_gridTarget);

	  update_grid<<<grid_size, block_size>>>(d_gridSource, d_gridTarget, num_cols, num_rows);
	//# addKernel<<<grid_size, block_size>>>(d_gridSource, d_gridTarget, d_result, num_cols, num_rows);
	  cudaDeviceSynchronize();
	  swap(&d_gridTarget, &d_gridSource);
	}

	stop = get_time_us();
	actual_runtime_without_copy = stop - start;
	}

	cudaMemcpy(h_resultGrid, d_gridTarget, sizeof(double) * gridLength, cudaMemcpyDeviceToHost);
 
 stop = get_time_us();
	actual_runtime_with_copy = stop - start;
 


	//printGrid(h_resultGrid, num_rows, num_cols);
	printf("\n\nResult Validity:");
	printf("\n \th_resultGrid[0]: %f", h_resultGrid[0]);
	printf("\n \th_resultGrid[1]: %f\n", h_resultGrid[1]);
	int numDots = 3;
	for (int i = 0; i < numDots; i++)
	{
		printf("\t  .\n");
	}
	uint offset = num_cols*num_rows;
	printf(" \th_resultGrid[%lu]: %f", offset - 2, h_resultGrid[offset - 2]);
	printf("\n \th_resultGrid[%lu]: %f\n", offset - 1, h_resultGrid[offset - 1]);


	char file_path[50];
	sprintf(file_path, "jacobi_heat_map_%" PRId64 "x%" PRId64 ".ppm", num_rows, num_cols);

	draw_grid(h_resultGrid, num_cols, num_rows, file_path);

 
	// Calculate the Bandwidth
 uint64_t total_bytes = (5 * sizeof(double) * gridLength); // => 4 load operations and 1 store operation
	uint64_t mega_bytes_per_second = (total_bytes / (actual_runtime_without_copy * 1e-6)) / 1e6;

	printf("\n\nTotal Bytes Loaded: %d GiB\n\n", (int)(total_bytes / 1e9));
	// Print Benchmark Output
	printf("\nFunction\t\t MB/s\t\t Time\n\n");
	fprintf(stdout, "Jacobi(Without COPY)   \t %" PRId64 "    \t %" PRId64 "\n", mega_bytes_per_second, actual_runtime_without_copy);


	total_bytes = (5 * sizeof(double) + sizeof(double)) * gridLength;
	mega_bytes_per_second = (total_bytes / (actual_runtime_with_copy * 1e-6)) / 1e6;
	fprintf(stdout, "Jacobi(With COPY)   \t %" PRId64 "    \t %" PRId64 "\n\n\n", mega_bytes_per_second, actual_runtime_with_copy);
 
 

	free(h_gridSource);
	free(h_gridTarget);
	free(h_resultGrid);

	cudaFree(d_gridSource);
	cudaFree(d_gridTarget);
	//cudaFree(d_result);

	return 0;
}
